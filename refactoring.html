<!DOCTYPE html>
<html>
  <head>
    <title>Ben Christel - ES6</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .remark-code {
        font-size: 24px;
        line-height: 125%;
      }

      .hljs-default .hljs {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle
      
# I spent two weeks refactoring 5 lines of code. Here's what I learned.

???

Those of you who have paired with me know that I love refactoring. Almost as much as I love JavaScript, which is more than any sane person should, probably. So of course this talk is about refactoring JavaScript.

This talk started out as propaganda for functional programming, which is why I spent two weeks refactoring 5 lines of code -- I was trying to refactor procedural code to a functional style and motivate the refactoring with something other than my own warm fuzzy feelings about functional programming. But I think the refactoring part is actually more interesting than the functional programming stuff, so my conclusions section is going to focus on that. 

---

class: middle

???

So I'll show you the code in a minute, but first I want to talk about the problem the code is supposed to solve. Basically, it takes a list of people, and renders their names as an HTML list. I call it the "leaderboard" problem just so it has some flavor other than sawdust. You can imagine that we're rendering the leaderboard for your favorite game, isn't that exciting.

--

```javascript
var people = [
  {name: 'Paxicorn'},
  {name: 'Varsuvius1337'}
  {name: 'xx_EliasTheGreat_xx'}
]
```

--

```html
<ol>
  <li>Paxicorn</li>
  <li>Varsuvius1337</li>
  <li>xx_EliasTheGreat_xx</li>
</ol>
```

---

class: middle

```javascript
function renderLeaderboard(people) {
  let listItems = []
  for (let i = 0; i < people.length; i++) {
    listItems[i] = '<li>' + people[i].name + '</li>'
  }
  return '<ol>' + listItems.join('\n') + '</ol>'
}
```

???

So without further ado, here's the five lines of code that solve this problem. For each person, we wrap their name in a list item, push it onto an array, then we join the list items into a string and wrap that in ordered list tags.

The first thing to notice is that it's kind of ugly but there's not really an obvious opportunity for refactoring. Sure, there's a tiny bit of duplication. We can pull that out.

---

class: middle

```javascript
function wrapInTag(tagName, string) {
  return '<' + tagName + '>' + string + '</' + tagName + '>'
}

function renderLeaderboard(people) {
  let listItems = []
  for (let i = 0; i < people.length; i++) {
    listItems[i] = wrapInTag('li', people[i].name)
  }
  return wrapInTag('ol', listItems.join('\n'))
}
```

???

And maybe this is slightly better. Honestly, I think it's probably not. And I think this is where a lot of people get stuck with refactoring, because they see code that's a little bit ugly but has no duplication, and they say "well, I guess that's as good as it gets". And this brings me to my first conclusion,

---

class: center, middle

# 2. Remove Duplication

which is that refactoring consists of two steps, and removing duplication is only step two.

---

# 1. Create Testable Units of Code
# 2. Remove Duplication

First you have to think about the units of code that you want to exist in your design. And if you're writing unit tests, they'll give you feedback about whether your design is any good. Then you pull the ugly code apart into those units. This will create duplication! But that's okay, because we can clean it up in step 2.

---

class: middle

1. &nbsp;
2. &nbsp;
3. &nbsp;
4. &nbsp;

???

So when I start thinking about how to decompose this problem into testable units of code, my instict is to think of the solution as a series of steps.

---

class: middle

1. Get names
2. &nbsp;
3. &nbsp;
4. &nbsp;

???

First we get the name property of each person

---

class: middle

1. Get names
2. Wrap in `<li>` tags
3. &nbsp;
4. &nbsp;

???

We wrap each name in an LI tag

---

class: middle

1. Get names
2. Wrap in `<li>` tags
3. Join on newlines
4. &nbsp;

???

Concatenate them into a string

---

class: middle

1. Get names
2. Wrap in `<li>` tags
3. Join on newlines
4. Wrap in an `<ol>` tag

???

And wrap the whole thing in an ordered list.

---

```javascript
function getNames() {
  /* ... */
}

function wrapInListItems() {
  /* ... */
}

function joinOnNewlines() {
  /* ... */
}

function wrapInOrderedList() {
  /* ... */
}
```

```javascript
function renderLeaderboard(people) {
  return wrapInOrderedList(
    joinOnNewlines(
      wrapInListItems(
        getNames(people)
      )
    )
  )
}
```

???

So we can easily express each of these steps as a function, and compose them in the obvious way. When we do that, we get a pyramid of doom, which is not nice, but fortunately we can write a higher order function to build the pyramid for us. I call this function `pipeline`, because it reminds me of the way the Unix pipe operator composes functions.

```
var renderLeaderboard = pipeline
  ( getNames
  , wrapInListItems
  , 
  )
```




    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
