<!DOCTYPE html>
<html>
  <head>
    <title>Ben Christel - ES6</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .remark-code {
        font-size: 24px;
        line-height: 125%;
      }

      .hljs-default .hljs {
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle
      
# I spent two weeks refactoring 5 lines of code. Here's what I learned.

???

Those of you who have paired with me know that I love refactoring. Almost as much as I love JavaScript, which is more than any sane person should, probably. So of course this talk is about refactoring JavaScript.

This talk started out as propaganda for functional programming, which is why I spent two weeks refactoring 5 lines of code -- I was trying to refactor procedural code to a functional style and motivate the refactoring with something other than my own warm fuzzy feelings about functional programming. But I think the refactoring part is actually more interesting than the functional programming stuff, so my conclusions section is going to focus on that. 

---

class: middle

???

So I'll show you the code in a minute, but first I want to talk about the problem the code is supposed to solve. Basically, it takes a list of people, and renders their names as an HTML list. I call it the "leaderboard" problem just so it has some flavor other than sawdust. You can imagine that we're rendering the leaderboard for your favorite game, isn't that exciting.

--

```javascript
var people = [
  {name: 'Paxicorn'},
  {name: 'Varsuvius1337'}
  {name: 'xx_EliasTheGreat_xx'}
]
```

--

```html
<ol>
  <li>Paxicorn</li>
  <li>Varsuvius1337</li>
  <li>xx_EliasTheGreat_xx</li>
</ol>
```

---

class: middle

```javascript
function renderLeaderboard(people) {
  let listItems = []
  for (let i = 0; i < people.length; i++) {
    listItems[i] = '<li>' + people[i].name + '</li>'
  }
  return '<ol>' + listItems.join('\n') + '</ol>'
}
```

???

So without further ado, here's the five lines of code that solve this problem. For each person, we wrap their name in a list item, push it onto an array, then we join the list items into a string and wrap that in ordered list tags.

The first thing to notice is that it's kind of ugly but there's not really an obvious opportunity for refactoring. Sure, there's a tiny bit of duplication. We can pull that out.

---

class: middle

```javascript
function wrapInTag(tagName, string) {
  return '<' + tagName + '>' + string + '</' + tagName + '>'
}

function renderLeaderboard(people) {
  let listItems = []
  for (let i = 0; i < people.length; i++) {
    listItems[i] = wrapInTag('li', people[i].name)
  }
  return wrapInTag('ol', listItems.join('\n'))
}
```

???

And maybe this is slightly better. Honestly, I think it's probably not. And I think this is where a lot of people get stuck with refactoring, because they see code that's a little bit ugly but has no duplication, and they say "well, I guess that's as good as it gets". And this brings me to my first conclusion,

---

class: center, middle

# 2. Remove Duplication

???

which is that refactoring consists of two steps, and removing duplication is only step two.

---

class: center, middle

# 1. Create Testable Units of Code
# 2. Remove Duplication

???

First you have to think about the units of code that you want to exist in your design. And if you're writing unit tests, they'll give you feedback about whether your design is any good. Then you pull the ugly code apart into those units. This will create duplication! But that's okay, because we can clean it up in step 2.

---

class: middle

1. &nbsp;
2. &nbsp;
3. &nbsp;
4. &nbsp;

???

So when I start thinking about how to decompose this problem into testable units of code, my instict is to think of the solution as a series of steps.

---

class: middle

1. Get names
2. &nbsp;
3. &nbsp;
4. &nbsp;

???

First we get the name property of each person

---

class: middle

1. Get names
2. Wrap in `<li>` tags
3. &nbsp;
4. &nbsp;

???

We wrap each name in an LI tag

---

class: middle

1. Get names
2. Wrap in `<li>` tags
3. Join on newlines
4. &nbsp;

???

Concatenate them into a string

---

class: middle

1. Get names
2. Wrap in `<li>` tags
3. Join on newlines
4. Wrap in an `<ol>` tag

???

And wrap the whole thing in an ordered list.

---

class: middle

```javascript
function getNames() {
  /* ... */
}

function wrapInListItems() {
  /* ... */
}

function joinOnNewlines() {
  /* ... */
}

function wrapInOrderedList() {
  /* ... */
}
```

---

class: middle

```javascript
function renderLeaderboard(people) {
  return wrapInOrderedList(
    joinOnNewlines(
      wrapInListItems(
        getNames(people)
      )
    )
  )
}
```

???

So we can easily express each of these steps as a function, and compose them in the obvious way. When we do that, we get a pyramid of doom, which is not nice, but fortunately we can write a higher order function to build the pyramid for us. I call this function `pipeline`, because it reminds me of the way the Unix pipe operator composes functions, although `buildPyramidOfDoom` would be a pretty badass name too.

---

class: middle

```javascript
let renderLeaderboard = pipeline
  ( getNames
  , wrapInListItems
  , joinOnNewlines
  , wrapInOrderedList
  )
```

???

Here's how we can use `pipeline` to build our `renderLeaderboard` function. This lets us write the names of the steps in order, instead of backwards as in the pyramid of doom. Also note that the definition of our render function is now completely declarative - there's no parameter list, no return statement, no function keyword - `pipeline` is building the whole thing for us.

---

class: middle

```javascript
let pipeline = (...args) =>
  args.reduce(compose, identity)

let compose = (f, g) => x => g(f(x))

let identity = x => x
```

???

Here's how `pipeline` is implemented. I'm going to skip over this part because it's not really interesting. If you care, the slides are on github.

---

class: middle

```javascript
function getNames(people) {
  let names = []
  for (let i = 0; i < people.length; i++) {
    names[i] = people[i].name
  }
  return names
}

function wrapInListItems(strings) {
  let listItems = []
  for (let i = 0; i < strings.length; i++) {
    listItems[i] = '<li>' + strings[i] + '</li>'
  }
  return listItems
}

function joinOnNewlines(strings) {
  return strings.join('\n')
}

function wrapInOrderedList(string) {
  return '<ol>' + string + '</ol>'
}
```

???

So I didn't show the implementation of our four step functions earlier, but now that we've defined the units of our system it's time to start reducing duplication. And as promised, we now have more duplication! The loop's duplicated. So let's replace that with a call to map

---

```javascript
function getNames(people) {
  return people.map(person => person.name)
}

function wrapInListItems(strings) {
  return strings.map(string => '<li>' + string + '</li>')
}

function joinOnNewlines(strings) {
  return strings.join('\n')
}

function wrapInOrderedList(string) {
  return '<ol>' + string + '</ol>'
}
```

???

and pull out a `wrapInHtmlTag` function again

---

```javascript
function getNames(people) {
  return people.map(person => person.name)
}

function wrapInListItems(strings) {
  return strings.map(string => wrapInHtmlTag('li', string))
}

function joinOnNewlines(strings) {
  return strings.join('\n')
}

function wrapInOrderedList(string) {
  return wrapInHtmlTag('ol', string)
}
```

???

This looks like it's as DRY as it's going to get. But there's still duplication -- there are two calls to `map`, and that means that we've increased duplication relative to our original procedural implementation. So we've just spun our wheels and gotten nowhere.

We also have this problem where even though we've pulled out all these nice, testable units, there's still duplication in our tests. When we test getNames, we have to build an array of people in our test setup, because the unit we're testing calls `map`. Same for wrapInListItems, we have to build an array. This extra setup we have to do is cruft, because we don't care about testing `map`. `map` is a library function, we don't need to test it, and we certainly don't need multiple tests covering it, which is what we've got here.

There's also the question of whether we want to have unit tests for wrapInHtmlTag. It's covered by two other tests, so maybe we don't need to test it, but it's a public interface, so maybe it should be tested just to make sure no one breaks it? But then, we again have duplicated coverage.

These problems happened because every time we saw duplication, we just extracted a function and called it, and that created a dependency. Functions with dependencies are annoying to test because you either have to stub the dependency or have tests that cover both the unit you're testing and all its dependencies.

So how do we get rid of these dependencies? Let's start with `map`. We've been thinking of `map` as a method that takes a function, applies it to each element of a collection, and returns a collection of the results. This is the way `map` works in Ruby, JavaScript and Java 8, but functional programming provides a much more powerful definition of `map`.

---

class: center, middle

# Map takes a function that operates on single values and creates an upgraded version that works on arrays.

???

Once we have this version of map, we can rewrite our pipeline like this:

---

class: middle

```javascript
let renderLeaderboard = pipeline
  ( map(getName)
  , map(wrapInListItem)
  , joinOnNewlines
  , wrapInOrderedList
  )
```

???

---

class: middle

```javascript
let renderLeaderboard = pipeline
  ( map(getName)
  , map(wrapInTag('li'))
  , joinOnNewlines
  , wrapInTag('ol')
  )
```

???

Here are the units that we ended up with:

---

class: center, middle

# pipeline
# map
# getName
# wrapInTag
# joinOnNewlines

???

There is no duplication between any of these units. There are no dependencies between them. That means they can be unit-tested with no duplicate coverage.

In my opinion, this is the only version of this code that's actually better than the procedural version. But we had to take a few big leaps to get there. So the moral of the story is, don't refactor without a plan.

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
